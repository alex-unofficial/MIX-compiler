* Constants and memory locations
TTY        EQU  19                    
BUFFER     EQU  3800                  
STACK      EQU  3000                  
* Program entry, initializes SP, FP and jumps to main
           ORIG 3000                  
START      ENT5 -STACK                 ; FP ← 0
           ENT6 -STACK                 ; SP ← 0
           JMP  FUNC000002             ; jump to main ≡ FUNC000002
* Pop result from stack and print
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           CHAR                       
           STA  BUFFER+7               ; high byte of result
           STX  BUFFER+8               ; low byte of result
           OUT  BUFFER(TTY)            ; print to TTY
           JBUS *(TTY)                 ; wait until printed
* Halt execution
           HLT                        
* Subroutine method1 entry (store RA & FP, FP ← SP, alloc n_locals)
FUNC000001 STJ  STACK+1,6              ; STACK[SP+1] ← RA ≡ rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] ← FP
           ENT5 2,6                    ; FP ← SP + 2
           INC6 2                      ; SP ← SP + 2
* Push a to stack
           LDA  STACK-2,5              ; rA ← a ≡ STACK[FP-2]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Negation operation on stack (pop A, push -A)
           LDAN STACK,6                ; rA ← -STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine method1 exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA ← result ≡ STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ENT6 0,5                    ; SP ← FP
           LD5  STACK,5(0:2)           ; FP ← old FP ≡ STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 ← RA ≡ STACK[SP-1]
           DEC6 3                      ; SP ← SP - 3
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
           JMP  0,4                    ; jump to RA
* Subroutine main entry (store RA & FP, FP ← SP, alloc n_locals)
FUNC000002 STJ  STACK+1,6              ; STACK[SP+1] ← RA ≡ rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] ← FP
           ENT5 2,6                    ; FP ← SP + 2
           INC6 3                      ; SP ← SP + 3
* Push 5 to stack
           LDA  =5=                    ; rA ← 5
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Push 10 to stack
           LDA  =10=                   ; rA ← 10
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Negation operation on stack (pop A, push -A)
           LDAN STACK,6                ; rA ← -STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Addition operation on stack (pop A, pop B, push A + B)
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ADD  STACK,6                ; rA ← rA + STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Pop a from stack
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           STA  STACK+1,5              ; STACK[FP+1] ≡ a ← rA
* Push a to stack
           LDA  STACK+1,5              ; rA ← a ≡ STACK[FP+1]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Negation operation on stack (pop A, push -A)
           LDAN STACK,6                ; rA ← -STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Call method method1 (pop params, push result)
           JMP  FUNC000001             ; jump to FUNC000001 ≡ method1
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine main exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA ← result ≡ STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ENT6 0,5                    ; SP ← FP
           LD5  STACK,5(0:2)           ; FP ← old FP ≡ STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 ← RA ≡ STACK[SP-1]
           DEC6 2                      ; SP ← SP - 2
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
           JMP  0,4                    ; jump to RA
* Initial contents of buffer
           ORIG BUFFER                
           ALF  "RETUR"               
           ALF  "N VAL"               
           ALF  "UE OF"               
           ALF  " MAIN"               
           ALF  " FUNC"               
           ALF  "TION:"               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
* Program end, begin execution at START
           END  START                 
