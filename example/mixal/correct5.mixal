* Constants and memory locations
TTY        EQU  19                    
BUFFER     EQU  3800                  
STACK      EQU  3000                  
* Program entry, initializes SP, FP and jumps to main
           ORIG 3000                  
START      ENT5 -STACK                 ; FP <- 0
           ENT6 -STACK                 ; SP <- 0
           JMP  FUNC000002             ; jump to main == FUNC000002
* Pop result from stack and print
           LDA  STACK,6                ; rA <- STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           CHAR                       
           STA  BUFFER+7               ; high byte of result
           STX  BUFFER+8               ; low byte of result
           OUT  BUFFER(TTY)            ; print to TTY
           JBUS *(TTY)                 ; wait until printed
* Halt execution
           HLT                        
* Subroutine fact entry (store RA & FP, FP <- SP, alloc n_locals)
FUNC000001 STJ  STACK+1,6              ; STACK[SP+1] <- RA == rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] <- FP
           ENT5 2,6                    ; FP <- SP + 2
           INC6 2                      ; SP <- SP + 2
* Push 1 to stack
           LDA  =1=                    ; rA <- 1
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Push n to stack
           LDA  STACK-2,5              ; rA <- n == STACK[FP-2]
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Comparison operation (>) on stack (pop A, pop B, push A > B)
           LDA  STACK,6                ; rA <- STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           CMPA STACK,6                ; CI <- rA ? STACK[SP]
           ENTX 1                      ; rX <- 1
           JG   1F                     ; lhs > rhs? continue
           ENTX 0                      ; else, overwrite rX <- 0
1H         STX  STACK,6                ; STACK[SP] <- rX
* evaluate branch condition
           LDA  STACK,6                ; rA <- STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           JAZ  ELSE000001             ; cond = false? jump to ELSE000001
* Push 1 to stack
           LDA  =1=                    ; rA <- 1
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Push n to stack
           LDA  STACK-2,5              ; rA <- n == STACK[FP-2]
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Subtraction operation on stack (pop A, pop B, push A - B)
           LDA  STACK,6                ; rA <- STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           SUB  STACK,6                ; rA <- rA - STACK[SP]
           STA  STACK,6                ; STACK[SP] <- rA
* Call method fact (pop params, push result)
           JMP  FUNC000001             ; jump to FUNC000001 == fact
* Push n to stack
           LDA  STACK-2,5              ; rA <- n == STACK[FP-2]
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Multiplication operation on stack (pop A, pop B, push A * B)
           LDA  STACK,6                ; rA <- STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           MUL  STACK,6                ; rAX <- rA * STACK[SP]
           STX  STACK,6                ; STACK[SP] <- rX
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
           JMP  DONE000001             ; jump to DONE000001
ELSE000001 NOP                        
* Push 1 to stack
           LDA  =1=                    ; rA <- 1
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
DONE000001 NOP                        
* Subroutine fact exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA <- result == STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           ENT6 0,5                    ; SP <- FP
           LD5  STACK,5(0:2)           ; FP <- old FP == STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 <- RA == STACK[SP-1]
           DEC6 3                      ; SP <- SP - 3
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
           JMP  0,4                    ; jump to RA
* Subroutine main entry (store RA & FP, FP <- SP, alloc n_locals)
FUNC000002 STJ  STACK+1,6              ; STACK[SP+1] <- RA == rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] <- FP
           ENT5 2,6                    ; FP <- SP + 2
           INC6 2                      ; SP <- SP + 2
* Push 5 to stack
           LDA  =5=                    ; rA <- 5
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
* Call method fact (pop params, push result)
           JMP  FUNC000001             ; jump to FUNC000001 == fact
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine main exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA <- result == STACK[SP]
           DEC6 1                      ; SP <- SP - 1
           ENT6 0,5                    ; SP <- FP
           LD5  STACK,5(0:2)           ; FP <- old FP == STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 <- RA == STACK[SP-1]
           DEC6 2                      ; SP <- SP - 2
           INC6 1                      ; SP <- SP + 1
           STA  STACK,6                ; STACK[SP] <- rA
           JMP  0,4                    ; jump to RA
* Initial contents of buffer
           ORIG BUFFER                
           ALF  "RETUR"               
           ALF  "N VAL"               
           ALF  "UE OF"               
           ALF  " MAIN"               
           ALF  " FUNC"               
           ALF  "TION:"               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
           ALF  "     "               
* Program end, begin execution at START
           END  START                 
