* Constants and memory locations
STACK      EQU  3000                  
* Program entry, initializes SP, FP and jumps to main
           ORIG 3000                  
START      ENT5 -STACK                 ; FP ← 0
           ENT6 -STACK                 ; SP ← 0
           JMP  FUNC000003             ; jump to main ≡ FUNC000003
           HLT                        
* Subroutine method1 entry (store RA & FP, FP ← SP, alloc n_locals)
FUNC000001 STJ  STACK+1,6              ; STACK[SP+1] ← RA ≡ rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] ← FP
           ENT5 2,6                    ; FP ← SP + 2
           INC6 3                      ; SP ← SP + 3
* Push 10 to stack
           LDA  =10=                   ; rA ← 10
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Push a to stack
           LDA  STACK-2,5              ; rA ← a ≡ STACK[FP-2]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Addition operation on stack (pop A, pop B, push A + B)
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ADD  STACK,6                ; rA ← rA + STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Pop b from stack
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           STA  STACK+1,5              ; STACK[FP+1] ≡ b ← rA
* Push b to stack
           LDA  STACK+1,5              ; rA ← b ≡ STACK[FP+1]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine method1 exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA ← result ≡ STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ENT6 0,5                    ; SP ← FP
           LD5  STACK,5(0:2)           ; FP ← old FP ≡ STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 ← RA ≡ STACK[SP-1]
           DEC6 3                      ; SP ← SP - 3
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
           JMP  0,4                    ; jump to RA
* Subroutine method2 entry (store RA & FP, FP ← SP, alloc n_locals)
FUNC000002 STJ  STACK+1,6              ; STACK[SP+1] ← RA ≡ rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] ← FP
           ENT5 2,6                    ; FP ← SP + 2
           INC6 3                      ; SP ← SP + 3
* Push c to stack
           LDA  STACK-2,5              ; rA ← c ≡ STACK[FP-2]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Call method method1 (pop params, push result)
           JMP  FUNC000001             ; jump to FUNC000001 ≡ method1
* Pop e from stack
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           STA  STACK+1,5              ; STACK[FP+1] ≡ e ← rA
* Push d to stack
           LDA  STACK-3,5              ; rA ← d ≡ STACK[FP-3]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Push e to stack
           LDA  STACK+1,5              ; rA ← e ≡ STACK[FP+1]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Addition operation on stack (pop A, pop B, push A + B)
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ADD  STACK,6                ; rA ← rA + STACK[SP]
           STA  STACK,6                ; STACK[SP] ← rA
* Pop e from stack
           LDA  STACK,6                ; rA ← STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           STA  STACK+1,5              ; STACK[FP+1] ≡ e ← rA
* Push e to stack
           LDA  STACK+1,5              ; rA ← e ≡ STACK[FP+1]
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine method2 exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA ← result ≡ STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ENT6 0,5                    ; SP ← FP
           LD5  STACK,5(0:2)           ; FP ← old FP ≡ STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 ← RA ≡ STACK[SP-1]
           DEC6 4                      ; SP ← SP - 4
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
           JMP  0,4                    ; jump to RA
* Subroutine main entry (store RA & FP, FP ← SP, alloc n_locals)
FUNC000003 STJ  STACK+1,6              ; STACK[SP+1] ← RA ≡ rJ
           ST5  STACK+2,6(0:2)         ; STACK[SP+2] ← FP
           ENT5 2,6                    ; FP ← SP + 2
           INC6 2                      ; SP ← SP + 2
* Push 6 to stack
           LDA  =6=                    ; rA ← 6
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Push 5 to stack
           LDA  =5=                    ; rA ← 5
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
* Call method method2 (pop params, push result)
           JMP  FUNC000002             ; jump to FUNC000002 ≡ method2
* Return from subroutine (return value is top of the stack)
           JMP  9F                     ; jump to method exit
* Subroutine main exit (restore FP & SP, dealloc params, push result, jump to RA)
9H         LDA  STACK,6                ; rA ← result ≡ STACK[SP]
           DEC6 1                      ; SP ← SP - 1
           ENT6 0,5                    ; SP ← FP
           LD5  STACK,5(0:2)           ; FP ← old FP ≡ STACK[SP]
           LD4  STACK-1,6(0:2)         ; rI4 ← RA ≡ STACK[SP-1]
           DEC6 2                      ; SP ← SP - 2
           INC6 1                      ; SP ← SP + 1
           STA  STACK,6                ; STACK[SP] ← rA
           JMP  0,4                    ; jump to RA
* Program end, begin execution at START
           END  START                 
